<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Trello</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jquery.ui/1.10.3/jquery-ui.min.js"></script>
  <script>
    $(function() {
      //$('.draggable').draggable();
    })
  </script>
  <app-root>Loading...</app-root>

<script>
var DragManager = new function() {

  /**
   * составной объект для хранения информации о переносе:
   * {
   *   elem - элемент, на котором была зажата мышь
   *   avatar - аватар
   *   downX/downY - координаты, на которых был mousedown
   *   shiftX/shiftY - относительный сдвиг курсора от угла элемента
   * }
   */
  var dragObject = {};

  function onMouseDown(e) {

    if (e.which != 1) return;
    var elem2=e.target.closest('.draggable');
    var elem;
    if (elem2) {
      dragObject.coords = getCoords(elem2);
      elem = elem2.cloneNode(true);
      elem2.remove();
    }
    if (!elem) return;
    dragObject.elem = elem;

    // запомним, что элемент нажат на текущих координатах pageX/pageY
    dragObject.downX = e.pageX;
    dragObject.downY = e.pageY;

    return false;
  }

  function onMouseMove(e) {
    if (!dragObject.elem) return; // элемент не зажат

    if (!dragObject.avatar) { // если перенос не начат...
      var moveX = e.pageX - dragObject.downX;
      var moveY = e.pageY - dragObject.downY;

      // если мышь передвинулась в нажатом состоянии недостаточно далеко
      if (Math.abs(moveX) < 3 && Math.abs(moveY) < 3) {
        return;
      }

      // начинаем перенос
      dragObject.avatar = createAvatar(e); // создать аватар
      if (!dragObject.avatar) { // отмена переноса, нельзя "захватить" за эту часть элемента
        dragObject = {};
        return;
      }

      // аватар создан успешно
      // создать вспомогательные свойства shiftX/shiftY
      dragObject.shiftX = dragObject.downX - dragObject.coords.left;
      dragObject.shiftY = dragObject.downY - dragObject.coords.top;

      startDrag(e); // отобразить начало переноса
    }

    // отобразить перенос объекта при каждом движении мыши
    dragObject.avatar.style.left = e.pageX - dragObject.shiftX + 'px';
    dragObject.avatar.style.top = e.pageY - dragObject.shiftY + 'px';
    var point = document.elementFromPoint(e.clientX, event.clientY);
    var card = point.closest('.card');
    var container=document.createElement('div');
    container.classList.add('container');
    container.classList.add('card');
    container.classList.add('droppable');
    if (card) {
      if (!card.classList.contains('container')) {
        var containers= document.getElementsByClassName('container');
        for (let i=0; i<containers.length; i++){
          containers[i].remove();
        }
        card.parentNode.insertBefore(container, card);
      }
    }
    return false;
  }

  function onMouseUp(e) {
    if (dragObject.avatar) { // если перенос идет
      finishDrag(e);
    }

    // перенос либо не начинался, либо завершился
    // в любом случае очистим "состояние переноса" dragObject
    dragObject = {};
    var containers= document.getElementsByClassName('container');
        for (let i=0; i<containers.length; i++){
          containers[i].remove();
        }
  }

  function finishDrag(e) {
    var dropElem = findDroppable(e);
    console.log(dropElem);
    if (!dropElem) {
      onDragCancel(dragObject);
    } else {
      onDragEnd(dragObject, dropElem);
    }

  }

  function createAvatar(e) {

    // запомнить старые свойства, чтобы вернуться к ним при отмене переноса
    var avatar = dragObject.elem;
    console.log(avatar);
    var old = {
      parent: avatar.parentNode,
      nextSibling: avatar.nextSibling,
      position: avatar.position || '',
      left: avatar.left || '',
      top: avatar.top || '',
      zIndex: avatar.zIndex || ''
    };
    console.log(old);
    // функция для отмены переноса
    avatar.rollback = function() {
      old.parent.insertBefore(avatar, old.nextSibling);
      avatar.style.position = old.position;
      avatar.style.left = old.left;
      avatar.style.top = old.top;
      avatar.style.zIndex = old.zIndex
    };

    return avatar;
  }

  function startDrag(e) {
    var avatar = dragObject.avatar;
    var cont=document.getElementById('content');
    // инициировать начало переноса
    cont.appendChild(avatar);
    avatar.style.zIndex = 1;
    avatar.style.position = 'absolute';
  }

  function findDroppable(event) {
    // спрячем переносимый элемент
    dragObject.avatar.hidden = true;

    // получить самый вложенный элемент под курсором мыши
    var elem = document.elementFromPoint(event.clientX, event.clientY);

    // показать переносимый элемент обратно
    dragObject.avatar.hidden = false;

    if (elem == null) {
      // такое возможно, если курсор мыши "вылетел" за границу окна
      return null;
    }

    return elem.closest('.droppable');
  }

  document.onmousemove = onMouseMove;
  document.onmouseup = onMouseUp;
  document.onmousedown = onMouseDown;

  

};


function getCoords(elem) { // кроме IE8-
  var box = elem.getBoundingClientRect();

  return {
    top: box.top + pageYOffset,
    left: box.left + pageXOffset
  };
}

onDragCancel = function(dragObject) {
  // откат переноса
  dragObject.avatar.rollback();
};
onDragEnd = function(dragObject, dropElem) {
  console.log('onDragEnd');
  console.log(dropElem);
  console.log(dropElem.parentNode);
  console.log(dragObject.elem);
  dropElem.parentNode.insertBefore(dragObject.elem, dropElem);
  //dragObject.elem=null;
};


</script>
</body>
</html>
